rein

# Общая информация

Простая среда для разработки и запуска программ,
написанных на Lua. Для экспериментов, обучения
программированию и быстрой разработки.

Цели rein:

- стимулировать творчество за счёт простоты подходов;
- быть независимой от ОС платформой для разработки;
- дать возможность легко экспериментировать;
- применяться для обучения.

Внимание! rein -- не фентези консоль. Творчество
стимулируется простотой подходов, а не ограничениями!

Возможности:

* растровая графика rgba (с возможностью работать с
  палитрой);
* развитый синтез звука;
* поддержка мыши, клавиатуры и геймпадов;
* инструменты разработки разрабатываются как обычные
  приложения rein;
* поддержка текстовых самодокументируемых форматов
  графики, музыки, муз. инструментов и шрифтов;
* поддержка потоков;
* работа с tcp/ip;
* возможность работать с форматами ttf/jpg/png.

## Отличия от существующих проектов

* pico8/tic80 и другие фентези консоли

В rein отсутствует привязка к разрешению и палитре.
Отсутствуют "искуственные" ограничения. Все
существующие (и будущие) инструменты создаются как
приложения на Lua. rein не следует "ретро" подходам,
однако не чужд этой эстетике.

* uxn

rein не является виртуальной архитектурой. Использует
Lua в качестве языка программирования.

* Love2d

rein гораздо проще, но при этом содержит в себе
интересные и самобытные решения. Он пытается быть не
только полезным, но и интересным для экспериментов
и обучения. Например, rein содержит в себе синтезатор.

## Настройки по умолчанию

- Графика 256x256;
- палитра из 16 цветов (Pico8);
- фиксированный шрифт 7x10.

## Запуск программ

Программа rein это текстовый файл - Lua-скрипт.
Программа может работать с внешними данными и
загружать ресурсы из файлов, но предпочтение отдаётся
текстовым форматам, которые "вшиваются" прямо в код.

Запуск программы: rein <путь к файлу>.

ВНИМАНИЕ! При запуске rein не переходит в каталог, в
котором находится скрипт!

В каталоге data/apps/ находятся скрипты, которые rein
может вызывать по имени "приложения". Например:

- edit - редактор;
- irc - irc клиент;
- sprited - редактор графики;
- voiced - редактор инструментов и трекер.

Пример запуска инструмента:

rein edit doc/api-ru.md

Редактор edit представляет из себя простую среду для
разработки. Вы можете запускать файл на выполнение,
нажав F5. Запускать редакторы графики (F8) и музыки
(F9).

Внимание! Для возврата в редактор воспользуйтесь
shift-esc.

Редактор графики и музыки ищет в тексте скрипта
строчки:

```
local __spr__ = ... -- спрайты
local __map__ = ... -- карта
local __voices__ = .. -- инструменты
local __songs__ = ... -- мелодии
```

Если такие фрагменты присутствуют, то они будут
загружены в редакторы графики/музыки (f8/f9) и
встроены обратно при сохранении. Вы также можетн
работать с редакторами и независимо от edit, копируюя
нужные данные вручную, или загружая их из файлов.

Попробуйте:

rein edit demo/aadv.lua

Нажмите F8, поменяйте какой-то спрайт, нажмите на
название файла для сохранения, затем shift-esc чтобы
вернуться в редактор и F5, чтобы увидеть свои
изменения! Потом, shift-esc чтобы снова вернуться в
редактор.

# Помощь

В редакторе помощь доступна по F1. В редакторах
графики/музыки - нажмите на "?".

Выполните: rein irc чтобы подключиться к чату #rein и
задайте вопрос там.

# Описание API

## Глобальные переменные

- ARGS - массив с аргументами. Первый элемент - путь к
  выполняемому скрипту;
- DATADIR - путь к каталогу data/ rein;
- VERSION - версия rein (строка);
- screen - объект-пиксели экрана;
- font - системный шрифт;
- sys - модуль системных функций;
- gfx - функции работы с графикой;
- synth - функции работы с синтезатором;
- mixer - функции работы с микшером;
- input - устройства ввода;
- thread - работа с потоками;
- utf - работа со строками UTF-8;
- net - TCP/IP.

## Цвет

При работе с gfx функциями в качестве цвета может быть указано:

- { r, g, b, a }, например { 127, 127, 0, 255 }. Если
  a (прозрачность) не указана, то подразумевается 255.
- число-индекс цвета в палитре.

Палитра может содержать 256 цветов (0..255). -1 -
означает прозрачный цвет.

Иногда в качестве "цвета" можно указать пиксели
(заливка шаблоном).

## gfx

gfx.pal(число, цвет) -- установить цвет палитры

local r, g, b, a = gfx.pal(цвет) -- взять цвет из
палитры и вернуть r, g, b, a

gfx.new(w, h) -- создать объект с пикселями WxH

gfx.new(файл) -- создать объект с пикселями из файла

gfx.new [[многострочный текст]] -- создать объект с
пикселями из текстового формата.

Например, напишите в edit строчку:

 local pic = gfx.new [[ - ]]

Выделите "-" между [[ ]] и нажмите F8. Нарисуйте
что-нибудь в редакторе, и нажмите на название файла
справа внизу. Затем, shift-esc. Вы увидите встроенную
картинку.

gfx.icon(пиксели) -- сменить иконку приложения

gfx.win(w, h) -- изменить/задать разрешение экрана. По
умолчанию размер области 256x256. Размер шрифта
выбирается автоматически (pico8, 8x8, 7x10), однако
для более высоких разрешений может понадобиться другой
"системный" шрифт. В таком случае, его можно задать 3м
параметром:

gfx.win(w, h, 'myfont.ttf')

gfx.win(пиксели) -- заменить экран на другой (вернёт
старый экран)

gfx.font(файл) -- загрузить шрифт (.ttf или .fnt) --
вы можете загружать и использовать свои не системные
шрифты в любое время. Формат .fnt это простой
текстовый формат. См. data/fonts. gfx.font() вернёт
объект типа font, с которым можно работать.

Методы объекта "шрифт":

:size(текст) - вернёт размер области, который будет
занимать данный текст при отрисовке;

:text(текст, цвет) - вернёт пиксели - отрисованный
текст.

Системный шрифт

Системный шрифт доступен как font и не доступен для
изменения. Он ипользуется для выдачи диагностических
сообщений. Кроме того, вам доступна функция gfx.print.
Она рисует текст в screen системным шрифтом.

```
gfx.print("текст", [x, y, цвет])
gfx.printf(x, y, цвет, "форматная строка", ...)
```

gfx.flip(время) - обновлять экран с заданной частотой

Все изменения экранной области осуществляются в
теневом буфере, чтобы "показать" его используется
gfx.flip(). Обычно, цикл программы выглядит так:

```
while sys.running() do
  -- ввод через sys.input()
  -- изменение изображения на экране
  gfx.flip(1/50) -- поддерживаем частоту 50Hz!
end
```

gfx.flip(1/50) сама поддерживает нужную частоту кадров
за счёт ожидания. Это нормальное поведение для игр,
однако для более низких частот это может быть
проблемой, так как пока flip "спит" пользователь может
осуществлять ввод. Для этого есть специальный режим:
прерывать сон при ввводе.

gfx.flip(1/10, true) - в таком случае, сон будет
прерываться во время ввода.

gfx.framedrop() - gfx.flip() может пропускать кадры
если не успевает достичь нужной частоты кадров. В этом
случае нет смысла рисовать кадр, ведь он всё-равно не
будет отрисован. Типовой сценарий использования:

```
if not gfx.framedrop() then -- узнать, будет ли
                            -- пропущен кадр?
  draw() -- отрисовка кадра
end

gfx.flip(1/60)
```

gfx.render() - отрисовать кадр немедленно и
безусловно. Не спит, не обрабатывает ввод.

gfx.border(цвет) - задать цвет бордюра

gfx.fg(цвет) - цвет по умолчанию для системных нужд
(gfx.print)

gfx.bg(цвет) - цвет по умолчанию для системных нужд
(gfx.print)

gfx.loadmap(текст или файл) -- чтение карты спрайтов

Карту спрайтов вы можете посмотреть на примере:

rein edit demo/aadv.lua затем f8, затем "m".

gfx.spr(пиксели, nr, x, y,  [w, [h, [flipx, [flipy]]]])
 - рисование спрайта из атласа спрайтов по 8x8

Атлас спрайтов это просто большая картинка в которой
размещены изображения в сетке 8x8. Изображения
нумеруются последовательно слева-направа и
сверху-вниз.

Так gfx.spr(__spr__, 2, 128, 128) берёт 3е (0.. 1.. 2)
изображение из атласа и рисует его по координатам 128,
128.

Экран представлен объектом с пикселями screen. Нет
разницы работаете ли вы с загруженными пикселями или с
экраном. Все методы доступные для пикселей так же
точно доступны и для scree. Например: screen:clear(15)

Методы пикселей

Данные методы могут выполняться на любых пикселях.
Например, на экране или изображениях, загруженных
gfx.new.

:val(x, y) - получить значения r, g, b, a

:val(x, y, цвет) - установить цвет

:clip(x1, y1, w, h) - установить границы рисования

:noclip() - убрать границы рисования

:offset(xoff, yoff) -- установить смещение рисования
(при рисовании в этот объект к координатам добавятся
xoff, yoff)

offset не действует для методов: buff, val.

:nooffset() -- установить смещение рисования в 0, 0

:pixel(x, y, цвет) -- нарисовать пиксель (с учётом
альфы)

:pixel(x, y) -- получить значение пикселя

:buff(таблица с числами, [x, y, w, h]) -- быстрое
заполнение буфера с пикселями из таблицы. Значение
таблицы:

```
r*0x1000000 + g*0x10000 + b*0x100 + a
```

:buff() - получить буфер с пикселями

:size() - получить ширину, высоту

:fill([x, y, w, h,] цвет) - заливка цветом

:fill([x, y, w, h,] пиксели) - заливка пикселями

:clear - как fill но просто затирание одного цвета
другим, без учёта прозрачности. Быстрее.

:copy([fx, fy, fw, fh, ]пиксели, [x, y]) --
копирование пикселей из одного объекта в другой

:blend -- как copy но с учётом прозрачности

:line(x1, y1, x2, y2, цвет) - линия

:line(x1, y1, x2, y2, пиксели) - линия по трафарету

:lineAA - как line, но с AA

:fill_triangle(x1, y1, x2, y2, x3, y3, цвет или
пиксели) - заливка треугольника

:circle(xc, yc, r) - окружность

:circle(xc, yc, пиксели) - окружность по трафарету

:circleAA - как circle, но с AA

:fill_circle(xc, yc, r, цвет или пиксели) - заливка
круга

:fill_poly({вершины}, цвет) - заливка полигона

:fill_rect(x1, y1, x2, y2, цвет) - заливка
прямоугольника

:fill_rect(x1, y1, x2, y2, пиксели) - заливка
прямоугольника пикселями

:poly({вершины}, цвет) - полигон

:poly({вершины}, пиксели) - полигон по трафарету

:polyAA - как poly, но с AA

:rect(x1, y1, x2, y2, цвет) - прямоугольник

:rect(x1, y1, x2, y2, пиксели) - прямоугольник по
трафарету

:rectAA - как rect, но с AA

:scale(xs, ys, smooth) - вернёт новые пиксели после
масштабирования

:flip(h, v) - создать отображённый по горизонтали
и/или вертикали спрайт (быстрее scale)

:stretch(пиксели, x, y, w, h) - растянуть или сжать
изображение и поместить его в пиксели в указанную
область. быстрее scale

## sys

sys.input() - возвращает события ввода. первое
значение - тип события, остальные - аргументы.

sys.input(false) - возвращает true если есть события
ввода

sys.input(true) - обнуляет очередь ввода  Тип события
представлен строкой: mousedown, mouseup, mousemotion,
keydown, keyup, mousewheel, quit.

sys.time() - время в секундах после запуска игры

sys.title(текст) - задать заголовок окна

sys.log(строка) - записать в диагностический лог

sys.readdir(путь) - прочитать содержимое каталога
(вернёт массив строк)

sys.chdir(путь) - сменить каталог

sys.dirname(путь) - вернёт каталог для пути. Может
быть использована с ARGS[1] чтобы узнать путь к
запущенному скрипту, чтобы прочитать данные,
хранящиеся во внешних файлах.

sys.mkdir(путь) - создать каталог

sys.sleep(секунд) - подождать

sys.go(функция) - создать Lua корутину и запустить в
рамках ядра, вернёт корутину

sys.stop(корутина) - остановить и убрать из списка
планируемых.

sys.exec(файл) - запустить .lua файл или app
приложение как корутину. За exec обычно следует
вызывать sys.stop или sys.suspend

sys.stop() - остановить текущую корутину

sys.suspend() - текущая корутина убирается из списка
планируемых, но после того как список останется пустым
(все корутины завершатся), возвращается в него.

sys.yield() - синоним coroutine.yiled()

sys.newrand([зерно]) - создать экземпляр датчика
случайных чисел на основе xoshiro128.

Единственный метод созданного sys.newrand датчика
случайных чисел это:

:rnd([старт,[конец]])

```
main = sys.newrand(12345)
main:rnd() -- нормированное случайное от 0 до 1
main:rnd(1, 5) -- от 1 до 5
main:rnd(3) -- от 1 до 3
```

sys.clipboard([текст]) -- получить или установить
текст в буффере обмена

sys.appdir(имя) -- получить каталог для сохранения
данных

## input

input.mouse() вернёт x, y и mb таблицу состояния
кнопок.

```
local x, y, mb = input.mouse()
if mb.left then...
```

input.keydown(клавиша) - вернёт true если клавиша
нажата.

input.keypress(клавиша) - как keydown, но сработает
один раз (до следующего нажатия).

## thread

thread.start(функция) - запустить поток (вернёт
объект - поток)

Методы потоков:

:wait() - ждать завершения

:read() - прочитать данные

:write() - передать данные

:poll(to) - есть ли пишуший, читающий (два boolean)
на той стороне? to - макс. время ожидания
В качестве данных можно передавать примитивные типы
Lua и пиксели.

Внимание! Поток запускается в чистом контексте Lua, в
котором доступен объект thead для синхронизации и
методы gfx/sys/utf/bit/net/synth. Пример работы с
потоками см. demo/plasmax.lua

## net

net.dial(хост, порт) -- создать tcp соединение и
вернуть неблокирующий сокет

:send(строка, [смещение,[длина]])

:recv()

:close()

Есть библиотека sock, которая может быть включена в
приложение и использована в блокирующем режиме. Пример
использования см. data/apps/irc.lua

## utf

Работа с utf строками.

utf.chars(строка) - вернёт массив символов unicode

utf.next(строка, [индекс]) - вернёт длину символа utf
в байтах (вперёд)

utf.prev(строка, [индекс]) - вернёт длину символа utf
в байтах (назад)

utf.len(строка) - длина строки в символах unicode

utf.codepoint(строка, [индекс]) - вернёт числовое
значение unicode символа в строке

utf.sym(строка, [индекс]) - вернёт один символ unicode
и длину символа в байтах в кодировке utf (как
utf.next)

## bit

Битовые операции (см. документацию по luabitops)

## mixer

mixer - отдельный поток который занимается
проигрыванием мелодий. Для работы с mixer необходимо
сначала загрузить банк с инструментами и банк с
мелодиями.

Звуковые эффекты тоже могут восприниматься как
мелодии.

mixer.voices(данные или файл) - загрузка инструментов
(создавать в voiced);

mixer.new(имя, данные) - загрузка отдельной мелодии;

mixer.songs(данные) - загрузка всех мелодий (создавать
в voiced);

mixer.volume(v) - общая громкость;

mixer.play(имя) - проиграть мелодию (вернёт
идентификатор);

mixer.status(идентификатор) - вернёт позицию
проигрывания или false, если мелодия не проигрывается;

mixer.stop(идентификатор, [время затухания]) -
остановить проигрывание мелодии.

mixer.reserve(число) - зарезервировать каналы для
прямого использования. Если вы собираетесь работать
с каналами напрямую через synth, то эти каналы надо
отобрать у mixer.

## synth

Синтезатор. 32 канала. synth считается низкоуровневым
интерфейсом, однако его удобно использовать для
более высокого уровня контроля воспроизведения
эффектов.

synth.on(канал) - включить канал.

synth.push(канал, имя) - добавит sfx генератор/эффект
на канал (synth, delay, dist, filter). Первый вызов
всегда synth.

synth.drop(канал) - снять все генераторы/эффекты с
канала.

synth.vol(канал, громкость) - громкость на канале
(нормированная 0-1)

synth.stop([канал]) - остановить и выключить канал
(все каналы)

synth.pan(канал, panning) - настроить центр стерео
(panning)

synth.chan_change(канал, параметр, [элемент],
                                        значение)

synth.change(канал, позиция sfx в стеке,
   параметр, [элемент], значение)

synth.mix(число самплов, громкость) - генерировать
данные аудио, вернёт число самплов которые удалось
записать до переполнения буфера или все самплы.

## sfx

Вспомогательная библиотека (требуется загрузка
require). Позволяет загружать банки инструментов и
мелодий. Удобно использовать совместно с synth.

sfx.voices(инструментов) - загрузить банк инструментов.

sfx.apply(канал, имя инструмент) - применить
инструменты.

## dump

dump.save(файл, таблица) -- сохранить данные таблицы в
файл

dump.load(файл) -- загрузить таблицу из файла

# Остальное

table, math, string, pairs, ipairs, io, tonumber,
tostring, coroutine -- проброшены "как есть".

error(ошибка) -- упасть по ошибке

## Форматы

Кроме привычных ttf/png поддерживаются свои простые
текстовые форматы, которые удобно встраивать прямо в
код. Например:

```
local s = gfx.new [[
--*
-*-*-*
*-*-*-
-*-*-*
*-*-*-
]]
```

В данном случае создастся изображение 6x3. Состоящее
из "сеточки" цвета с индексом 2.

Вы можете сделать screen:fill(s) и посмотреть, что
будет :)

1я строка текста - соответствия символов ascii в цвета
палитры. Например: --* означает, что символом *
кодируется цвет 2. 0123456789abcdef -- все 16 цветов
кодируются символами от 0 до f Далее идут строки с
изображением. - -- прозрачный. Остальные символы
соответствуют кодированию палитры.

Формат шрифтов можно посмотреть открыв файл
data/fonts/8x8.fnt

Пример формата мелодии:

```
local __songs__ = [[
song title
@tempo 16
@voice 1 bass
@voice 2 snare
@voice 3 square
@voice 4 saw
@vol -1 0.5
@pan -1 0
@pan 3 -0.75
@pan 4 0.75
| c-3 a0 | ... .. | c-5 .. | c-4 64
| ... .. | ... .. | g-4 45 | ... ..
| c-3 80 | ... .. | c-5 .. | ... ..
| ... .. | ... .. | c-5 45 | ... ..
| ... .. | c-4 80 | d-5 .. | ... ..
| ... .. | ... .. | c-5 45 | ... ..
| ... .. | ... .. | d-5 .. | ... ..
| ... .. | c-4 80 | d-5 45 | ... ..
| c-3 a0 | ... .. | d#5 .. | ... ..
| ... .. | c-4 80 | d-5 45 | ... ..
| c-3 80 | ... .. | d#5 .. | ... ..
| ... .. | ... .. | d#5 45 | ... ..
| ... .. | c-4 80 | f-5 .. | ... ..
| ... .. | ... .. | d#5 45 | ... ..
| ... .. | ... .. | g-5 .. | ... ..
]]
```

Пример формата инструментов:

```
local __voices__ = [[
  voice bass
  box synth
  fmul freq 0.5
  type square
  width 0
  decay 0.2
  sustain 0
  release 0.01
  volume 0.5
  lfo_assign 0 freq
  lfo_type 0 saw
  lfo_freq 0 15
  lfo_low 0 100
  lfo_high 0 -100
  lfo_set_loop 0 0
  lfo_assign 1 width
  lfo_type 1 saw
  lfo_freq 1 15
  lfo_low 1 0.5
  lfo_high 1 -0.5
  lfo_set_loop 1 0

  voice snare
  box synth
  type lin_band_noise
  volume 0.5
  offset 10000
  width 10000
  fmul freq 0.4
  decay 0.15
  sustain 0
  release 0
  lfo_assign 1 freq
  lfo_type 1 saw
  lfo_freq 1 5
  lfo_low 1 9500
  lfo_high 1 5000
  lfo_set_loop 1 0

  box synth
  type sin
  decay 0.15
  sustain 0
  release 0
  lfo_assign 0 freq
  lfo_type 0 saw
  lfo_freq 0 10
  lfo_low 0 200
  lfo_high 0 -70
  lfo_set_loop 0 0
]]
```

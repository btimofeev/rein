# Общая информация

По умолчанию: 256x256, 16 цветов палитры pico8, возможность работы с rgba сохранена.
data/core/core.lua -- микроядро. здесь доступны все функции платформы.
data/core/api.lua -- пример реализации конкретного api.

# Цвет

Цвета могут задаваться в виде rgba, например:

{ 127, 127, 0, 255 }

Или в виде индекса в палитре. Палитра может содержать 256 цветов (0..255). -1 -- прозрачный { 0, 0, 0, 0 }

# data/core/api.lua

Это тот файл, который настраивает среду исполнения вашей игры.

# gfx

gfx.pal(число, цвет) -- установить цвет палитры
local r, g, b, a = gfx.pal(цвет) -- взять цвет и вернуть r, g, b, a

gfx.new(w, h) -- создать объект с пикселями wxh
gfx.new(файл) -- создать объект с пикселями из файла (.png, .spr)
gfx.icon(пиксели) -- сменить иконку приложения
gfx.icon(пиксели)
gfx.win(w, h) -- изменить разрешение экрана
gfx.win(пиксели) -- заменить экран на другой (вернёт старый экран)
gfx.font(файл) -- загрузить шрифт (.ttf или .fnt)
gfx.flip(время) -- отрисовать окно и поддерживать заданный fps, например:
gfx.flip(1/50) -- держим частоту 50Hz
gfx.border(цвет) -- задать цвет бордюра
gfx.fg(цвет) -- цвет по умолчанию для системных нужд (print)
gfx.bg(цвет) -- цвет по умолчанию для системных нужд (print)
Экран представлен объектом с пикселями screen. Например: screen:clear(15)

# методы пикселей

Данные методы могут выполняться на любых пикселях. Например, на экране или изображениях,
загруженных gfx.new.

:val(x, y) -- получить значения r, g, b, a
:val(x, y, цвет) -- установить цвет
:clip(x1, y1, x2, y2) -- установить границы рисования
:noclip() -- убрать границы рисования
:offset(xoff, yoff) -- установить смещение рисования (при рисовании в этот объект к координатам добавятся xoff, yoff)
:nooffset() -- установить смещение рисования в 0, 0
:pixel(x, y, цвет) -- нарисовать пиксель (с учётом альфы)
:buff(таблица с числами, [x, y, w, h]) -- быстрое заполнение буфера с пикселями из таблицы. Значение таблицы: r*0x1000000+g*0x10000*b*0x100+a
:buff() -- получить буфер с пикселями
:size() -- получить w и h
:fill([x, y, w, h,] цвет) -- заливка цветом
:fill([x, y, w, h,] пиксели) -- заливка пикселями
:clear -- как fill но просто затирание одного цвета другим, без учёта прозрачности. Быстрее.
:copy([fx, fy, fw, fh, ]пиксели, [x, y]) -- копирование пикселей из одного объекта в другой
:blend -- как copy но с учётом прозрачности
:line(x1, y1, x2, y2, цвет) -- линия
:lineAA -- как line, но с AA
:fill_triangle(x1, y1, x2, y2, x3, y3, цвет или пиксели) -- заливка треугольника
:circle(xc, yc, r) -- окружность
:circleAA -- как circle, но с AA
:fill_circle(xc, yc, r, цвет или пиксели) -- заливка круга
:fill_poly({вершины}, цвет) -- заливка полигона
:poly({вершины}, цвет) -- полигон
:polyAA -- как poly, но с AA
:scale(xs, ys) -- вернёт новые пиксели после масштабирования
:stretch(пиксели, x, y, w, h) -- растянуть или сжать изображение и поместить его в пиксели в указанную область. быстрее scale

# методы шрифта

Системный шрифт доступен как font. Вы не можете его менять, но можете загружать другие шрифты и использовать их.

:size(текст) -- рассчитать ширину и высоту текста без рендеринга
:text(текст, цвет) -- создать пиксели с отрендеренным текстом

Вам доступна функция print. Она рисует текст в screen и переносит слова при выходе за границу окна. Удобна для диагностики проблем. Но может быть использована для других целей.

print("текст", [x, y, цвет])
printf(x, y, цвет, "форматная строка", ...)

# sys

sys.input() -- возвращает события ввода. первое значение - тип события, остальные - аргументы.

Типы: mousedown, mouseup, mousemotion, keydown, keyup, mousewheel, quit...

sys.time() -- время в секундах после запуска игры
sys.title(текст) -- задать заголовок окна
sys.log(строка) -- записать в лог
sys.readdir(путь) -- прочитать содержимое каталога
sys.chdir(путь) -- сменить каталог
sys.mkdir(путь) -- создать каталог
sys.sleep(секунд) -- сон
sys.go(функция) -- создать корутину и запустить в рамках core (планировать не надо), вернёт корутину
sys.stop(корутина) -- остановить и убрать из списка планируемых
sys.yield() -- синоним coroutine.yiled()

# input

input.mouse() вернёт x, y и mb таблицу состояния кнопок.
local x, y, mb = input.mouse()
if mb.left then...

input.keydown(клавиша) -- вернёт true если клавиша нажата.

# thread

thread.start(функция) -- запустить поток (вернёт объект - поток)
методы потоков:
:wait() -- ждать завершения
:read() -- прочитать данные
:write() -- передать данные

В качестве данных можно передавать примитивные типы lua и пиксели.

# utf

Работа с utf строками.
utf.new("текст")
:sub(s, e)
:iter()
:len()

# bit

Битовые операции (luabitops)

# mixer

Пока в работе. Внутри использует не проброшенную system.audio(буфер).

# Остальное

table, math, string, pairs, ipairs, io, tonumber, tostring, coroutine -- проброшены "как есть".
dump -- пока не проброшено (сериализация структур данных lua).

dprint(текст) -- для отладки. печатает в консоль и лог.
error(ошибка) -- упасть по ошибке

# Форматы

Кроме привычных ttf/png поддерживаются свои простые текстовые форматы, которые удобно встраивать прямо в код. Например:

local s = gfx.new [[
--*
-*-*-*
*-*-*-
-*-*-*
*-*-*-
]]

В данном случае создастся изображение 6x3. Состоящее из "сеточки" цвета с индексом 2.

Вы можете сделать screen:fill(s) и посмотреть, что будет :)

1я строка текста - соответствия символов ascii в цвета палитры.
Например: --* означает, что символом * кодируется цвет 2.
0123456789abcdef -- все 16 цветов кодируются символами от 0 до f
Далее идут строки с изображением. - -- прозрачный. Остальные символы соответствуют кодированию палитры.

Формат шрифтов можно посмотреть открв файл data/fonts/8x8.fnt
